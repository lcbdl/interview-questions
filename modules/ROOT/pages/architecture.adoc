= Architecture & Design

== What are the Microservices architecture principles?

Microservices architecture is a design approach that structures an application as a collection of loosely coupled, independently deployable services. Each service corresponds to a specific business function and communicates with other services through well-defined APIs. The principles of microservices architecture are essential for effectively implementing and managing such a system. Here are the key principles:

* Single Responsibility Principle: Each microservice should have a single responsibility, focusing on a specific business capability or function. This makes the service easier to understand, develop, and maintain.   

* Loose Coupling: Services should be as independent as possible. Changes in one service should not require changes in others. This is achieved through well-defined interfaces and communication protocols.
      
* Autonomy: Microservices should be autonomous, meaning they can be developed, deployed, and scaled independently. This independence enhances flexibility and allows teams to choose the best tools and technologies for their specific service.
      
* Continuous Delivery and DevOps: Microservices architecture supports continuous delivery practices, enabling frequent, reliable releases. DevOps practices, including automated testing, integration, and deployment, are essential to manage the complexity of multiple services.
      
* Decentralized Data Management: Instead of a single, centralized database, each microservice manages its own data. This ensures that services are independent and reduces the risk of a single point of failure.
      
* API-First Design: Services communicate through well-defined APIs. An API-first approach ensures that the service interface is designed before implementation, promoting consistency and usability.
      
* Failure Isolation: The architecture should be designed to isolate failures. If one service fails, it should not cause a cascading failure across the system. This can be achieved through techniques like circuit breakers and bulkheads.

** The circuit breaker pattern is implemented on the consumer, to avoid overwhelming a service which may be struggling to handle calls. Example here that uses resilience4j-spring-boot3
** The bulkhead pattern is implemented on the service, to prevent a failure during the handling of a single incoming call impacting the handling of other incoming calls. Example here that uses resilience4j-spring-boot2.
      
* Scalability: Each microservice can be scaled independently based on demand. This allows for more efficient use of resources compared to scaling an entire monolithic application.
      
* Polyglot Persistence and Programming: Microservices can use different technologies and languages best suited for their specific requirements. This flexibility allows teams to choose the most appropriate tool for each job.
      
* Monitoring and Logging: Due to the distributed nature of microservices, comprehensive monitoring and logging are crucial. This helps in diagnosing issues, understanding system behavior, and ensuring reliability.
      
* Event-Driven Architecture: Services often communicate asynchronously through events. This decouples services and allows them to react to changes in other services without direct dependencies.
      
* Security: Each microservice should implement security measures to protect its data and operations. Security must be considered at every level, from API security to data encryption and authentication mechanisms.

== How to implement services to ensure actions are only processed once, even in case of retries or failures?

Implementing idempotent services ensures that the same action is not processed multiple times, even in the face of retries or failures. Idempotence is crucial in distributed systems where network issues or service failures can lead to repeated requests. Here are some strategies and techniques to achieve idempotency:

=== 1. Unique Request Identifiers
Use unique request identifiers (IDs) for each request. This can be a UUID or another unique token generated by the client or the service.

* Client-Side Generation: The client generates a unique ID for each request and sends it along with the request.
* Server-Side Generation: The server generates a unique ID for each request and returns it to the client, which must use it for subsequent retries.

Implementation Steps:

.. When a request is received, check if the unique ID has already been processed.
.. If the ID is found in the database, return the result of the previous processing.
.. If the ID is not found, process the request and store the result along with the ID.

=== 2. Idempotency Keys

An idempotency key is similar to a unique request ID but is typically used for specific operations that need idempotency.

Implementation Steps:

.. Generate an idempotency key for operations that need to be idempotent.
.. Store the key and the result of the operation in a database or cache.
.. On receiving a request with the same idempotency key, return the previously stored result instead of reprocessing the request.

=== 3. Database Constraints

Utilize database constraints to ensure that certain operations are only performed once.

Implementation Steps:

.. Use unique constraints on columns that should not have duplicate entries.
.. Attempt to insert the data. If the insertion fails due to a unique constraint violation, handle the failure gracefully by either returning the existing record or taking appropriate action.

=== 4. Distributed Locks

Use distributed locks to prevent concurrent processing of the same request.

Implementation Steps:

.. Acquire a lock for the specific resource or operation before processing the request.
.. Ensure that only one instance of the service can hold the lock at a time.
.. Process the request and release the lock.

=== 5. Middleware or Interceptors

Implement middleware or interceptors that handle idempotency checks and enforce idempotent behavior before the actual business logic is executed.

Implementation Steps:

.. Intercept incoming requests and extract the unique ID or idempotency key.
.. Perform the idempotency check in the middleware.
.. Pass the request to the business logic only if it hasn’t been processed before.

=== 6. Eventual Consistency

Design the system to handle eventual consistency, ensuring that repeated operations lead to the same result.

Implementation Steps:

.. Design operations to be naturally idempotent, e.g., setting a value (PUT) instead of incrementing (POST).
.. Use compensating transactions to reverse duplicate effects.

Practical Example: Payment Processing Service

Let’s consider implementing idempotency in a payment processing service:

.. Unique Request ID: The client generates a unique request ID for each payment request and sends it to the server.
.. Idempotency Key: The server receives the request and checks if the request ID already exists in the database.
  * If it exists, it returns the result of the previous processing.
  * If it doesn’t exist, it processes the payment and stores the request ID along with the payment result.
.. Database Constraints: The payment record might use a unique constraint on the transaction ID to ensure that duplicate transactions are not recorded.
.. Distributed Lock: A distributed lock (e.g., using Redis) ensures that only one instance of the service processes the payment request at a time.
.. Middleware: Middleware intercepts the request, performs the idempotency check, and only forwards the request to the business logic if it’s not a duplicate.

.Code Example in Pseudocode:
[source python]
----
def process_payment(request):
  request_id = request.headers['Request-ID']

  # Check if request ID already processed
  existing_payment = db.find_payment_by_request_id(request_id)
  if existing_payment:
      return existing_payment.result

  # Acquire distributed lock
  with distributed_lock(request_id):
      # Check again to handle race conditions
      existing_payment = db.find_payment_by_request_id(request_id)
      if existing_payment:
          return existing_payment.result

      # Process payment
      result = payment_gateway.process(request)
      
      # Store result with request ID
      db.save_payment_result(request_id, result)
      
      return result
----

== What are reactive programming paradigms like Project Reactor's Flux?

Reactive programming is a paradigm that focuses on asynchronous data streams and the propagation of changes. It is well-suited for applications that require high performance, scalability, and responsiveness. Project Reactor, a library for building reactive applications on the JVM, is a key player in this space. It provides two primary types: Mono and Flux. Flux is used for handling sequences of 0 to N items, while Mono handles 0 or 1 item.

=== 1. Key Concepts of Reactive Programming

. Asynchronous Data Streams: Reactive programming deals with data as streams that can emit items asynchronously over time.
. Event-Driven: Actions are driven by events (data, user inputs, etc.), and the system reacts to these events.
. Backpressure: A mechanism to handle situations where the producer of data is faster than the consumer, preventing the consumer from being overwhelmed.
. Non-blocking: Reactive systems avoid blocking operations, enhancing performance and scalability.

=== 2. Project Reactor

Project Reactor is an implementation of the Reactive Streams specification, providing a powerful and flexible foundation for reactive applications. It offers a rich set of operators to transform, filter, and combine data streams.

=== 3. Flux: Reactive Sequences of Data

Flux is a reactive type representing a sequence of 0 to N items, potentially infinite. It is a key abstraction in Project Reactor for working with multiple items.

==== Creating a Flux
You can create a Flux using various factory methods:

* Just: Creates a Flux that emits specified items.

[source java]
----
Flux<String> flux = Flux.just("item1", "item2", "item3");
----

* FromIterable: Converts an Iterable into a Flux.

[source java]
----
List<String> items = Arrays.asList("item1", "item2", "item3");
Flux<String> flux = Flux.fromIterable(items);
----

* Range: Generates a range of integers.

[source java]
----
Flux<Integer> rangeFlux = Flux.range(1, 5); // Emits 1, 2, 3, 4, 5
----

==== Transforming a Flux
Flux provides various operators to transform the emitted items:

* Map: Applies a function to each item and emits the result.

[source java]
----
Flux<String> flux = Flux.just("a", "b", "c")
    .map(String::toUpperCase); // Emits "A", "B", "C"
----
==== Filter: Filters items based on a predicate.

[source java]
----
Flux<Integer> evenFlux = Flux.range(1, 10)
    .filter(i -> i % 2 == 0); // Emits 2, 4, 6, 8, 10
----

==== FlatMap: Transforms each item into a Publisher and flattens them.

[source java]
----
Flux<String> flatMappedFlux = Flux.just("flux", "mono")
  .flatMap(s -> Flux.fromArray(s.split(""))); 
  // Emits "f", "l", "u", "x", "m", "o", "n", "o"
----

==== Handling Errors

Reactive programming emphasizes handling errors as part of the stream:

* OnErrorReturn: Provides a fallback value when an error occurs.

[source java]
----
Flux<Integer> flux = Flux.just(1, 2, 0)
  .map(i -> 10 / i)
  .onErrorReturn(-1); // Emits 10, 5, -1
----

* OnErrorResume: Switches to another Flux when an error occurs.

[source java]
----
Flux<Integer> flux = Flux.just(1, 2, 0)
  .map(i -> 10 / i)
  .onErrorResume(e -> Flux.just(100, 200));
  // Emits 10, 5, 100, 200
----

==== Backpressure Handling

Project Reactor provides mechanisms to handle backpressure, ensuring that the consumer is not overwhelmed by the producer:

* Buffer: Collects items into a List and emits them as a single item.

[source java]
----
Flux<List<Integer>> bufferedFlux = Flux.range(1, 10).buffer(3); 
// Emits [1, 2, 3], [4, 5, 6], [7, 8, 9], [10]
----

* Window: Splits the Flux into smaller Flux windows.

[source java]
----
Flux<Flux<Integer>> windowedFlux = Flux.range(1, 10).window(3); 
// Emits Fluxes containing [1, 2, 3], [4, 5, 6], [7, 8, 9], [10]
----

==== Example: Combining Flux and Mono
[source java]
----
Mono<String> mono = Mono.just("Reactive Programming");
Flux<String> combinedFlux = Flux.just("with", "Project Reactor")
    .startWith(mono); 
// Emits "Reactive Programming", "with", "Project Reactor"
----

== What is Spring Integration for building message-driven microservices and event-driven architectures?

Spring Integration is a module of the Spring Framework that provides a framework for building message-driven applications and systems using well-established enterprise integration patterns. It facilitates the development of event-driven architectures and microservices by enabling the integration of various systems through messaging. This allows for loosely coupled, scalable, and easily maintainable systems.

=== 1. Key Concepts in Spring Integration

. Messages: The core abstraction in Spring Integration. A message consists of a payload and headers.

* Payload: The actual data being transferred.
* Headers: Metadata about the message (e.g., timestamp, correlation ID).

. Channels: Pathways for messages to travel between different components.

* Direct Channels: Synchronous communication between components.
* Queue Channels: Asynchronous communication using in-memory queues.
* Publish-Subscribe Channels: Broadcast messages to multiple subscribers.

. Endpoints: Components that produce or consume messages.

* Message Producers: Generate messages (e.g., service activators, inbound adapters).
* Message Consumers: Process messages (e.g., outbound adapters, service activators).
* Message Transformers: Convert messages from one format to another.
* Message Filters: Allow or disallow messages based on criteria.
* Message Routers: Direct messages to different channels based on conditions.

. Adapters: Bridge between Spring Integration and external systems (e.g., databases, file systems, messaging systems like RabbitMQ, Kafka).

. Gateways: Provide a higher-level abstraction to send and receive messages, acting as entry and exit points for messages in the system.

=== 2. Building Message-Driven Microservices

Message-driven microservices are designed to communicate through messaging systems, making them highly decoupled and resilient. Spring Integration helps in building such systems by providing support for various messaging patterns and integration with popular message brokers.

==== Example: Building a Message-Driven Microservice with Spring Integration

===== 1. Setup Dependencies

Include Spring Integration and a messaging library (e.g., RabbitMQ, Kafka) in your pom.xml (for Maven) or build.gradle (for Gradle).

[source xml]
----
<!-- Maven -->
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-amqp</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.amqp</groupId>
    <artifactId>spring-rabbit</artifactId>
</dependency>
----

===== 2. Configure Message Channels:
Define channels to be used for communication between components.

[source java]
----
@Configuration
public class IntegrationConfig {
    @Bean
    public MessageChannel inputChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel outputChannel() {
        return new DirectChannel();
    }
}
----

===== 3. Define Integration Flows:
Create integration flows that describe how messages move through the system.
[source java]
----
@Configuration
@EnableIntegration
public class IntegrationFlowConfig {

    @Bean
    public IntegrationFlow processFlow() {
        return IntegrationFlows.from("inputChannel")
                .transform((String payload) -> payload.toUpperCase())
                .handle(System.out::println)
                .channel("outputChannel")
                .get();
    }
}
----

===== 4. Message Producer and Consumer:
Implement message producers and consumers. Producers send messages to the channels, and consumers process the messages from the channels.

[source java]
----
@Service
public class MessageProducer {
    private final MessageChannel inputChannel;

    @Autowired
    public MessageProducer(@Qualifier("inputChannel") MessageChannel inputChannel) {
        this.inputChannel = inputChannel;
    }

    public void sendMessage(String message) {
        inputChannel.send(MessageBuilder.withPayload(message).build());
    }
}

@Service
public class MessageConsumer {
    @ServiceActivator(inputChannel = "outputChannel")
    public void consume(String message) {
        System.out.println("Received message: " + message);
    }
}
----

=== 3. Building Event-Driven Architectures
Event-driven architectures leverage events to trigger changes and communications between microservices. Spring Integration makes it straightforward to build such systems by providing robust support for event handling and processing.

==== Example: Event-Driven Architecture with Spring Integration and Kafka

===== 1. Setup Dependencies:
Include Spring Integration and Kafka dependencies.

[source xml]
----
<!-- Maven -->
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-core</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-kafka</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.kafka</groupId>
    <artifactId>spring-kafka</artifactId>
</dependency>
----

===== 2. Configure Kafka Components:
Set up Kafka producer and consumer factories, along with the Kafka template.

[source java]
----
@Configuration
public class KafkaConfig {
    @Bean
    public ProducerFactory<String, String> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, String> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "group_id");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        return new DefaultKafkaConsumerFactory<>(configProps);
    }
}
----

===== 3. Define Integration Flows for Kafka:

[source java]
----
@Configuration
@EnableIntegration
public class KafkaIntegrationConfig {

    @Bean
    public IntegrationFlow kafkaProducerFlow(KafkaTemplate<String, String> kafkaTemplate) {
        return IntegrationFlows.from("kafkaInputChannel")
                .handle(Kafka.outboundChannelAdapter(kafkaTemplate)
                        .topic("myTopic"))
                .get();
    }

    @Bean
    public IntegrationFlow kafkaConsumerFlow(ConsumerFactory<String, String> consumerFactory) {
        return IntegrationFlows.from(Kafka.messageDrivenChannelAdapter(consumerFactory, "myTopic"))
                .handle(message -> {
                    System.out.println("Received from Kafka: " + message.getPayload());
                })
                .get();
    }
}
----

===== 4. Message Producer and Consumer Services:
[source java]
----
@Service
public class KafkaMessageProducer {
    private final MessageChannel kafkaInputChannel;

    @Autowired
    public KafkaMessageProducer(@Qualifier("kafkaInputChannel") MessageChannel kafkaInputChannel) {
        this.kafkaInputChannel = kafkaInputChannel;
    }

    public void sendMessage(String message) {
        kafkaInputChannel.send(MessageBuilder.withPayload(message).build());
    }
}
----

== How to secure PWA and encrypting local data to safeguard sensitive information?

Securing a Progressive Web Application (PWA) and encrypting local data are critical steps to safeguard sensitive information. Here are some best practices and techniques to ensure your PWA is secure and handles data securely.

=== 1. Use HTTPS
Always serve your PWA over HTTPS to ensure secure communication between the client and server.

* Get an SSL Certificate: Obtain and install an SSL certificate for your domain.
* Redirect HTTP to HTTPS: Configure your server to redirect all HTTP traffic to HTTPS.

=== 2. Implement Content Security Policy (CSP)
A Content Security Policy helps prevent various attacks like Cross-Site Scripting (XSS) and data injection attacks.

* Define a CSP Header: Configure your server to include a CSP header in responses.

[source html]
----
Content-Security-Policy: default-src 'self'; script-src 'self' 'sha256-xyz'; style-src 'self' 'sha256-abc'
----

* Use Nonce or Hash: Use nonces or hashes for scripts and styles to restrict which sources can be executed.

=== 3. Secure Service Workers
Service workers operate in the background and have access to network requests and cached data.

* Scope Limitation: Restrict the scope of the service worker to only the paths it needs to control.
[source java]
----
navigator.serviceWorker.register('/sw.js', { scope: '/' });
----

* Validate Requests: Ensure service workers validate and sanitize all incoming data and requests.

=== 4. Authentication and Authorization
Secure user authentication and manage access control to sensitive data.

* Use OAuth or OpenID Connect: Implement OAuth 2.0 or OpenID Connect for secure authentication.
* Token-Based Authentication: Use tokens (e.g., JWT) to manage user sessions securely.
* Role-Based Access Control: Implement role-based access control to restrict access to specific parts of your application.

=== 5. Encrypt Local Data
Encrypting data stored locally in the browser (e.g., IndexedDB, localStorage) is essential for protecting sensitive information.

==== Using Web Crypto API
The Web Crypto API provides cryptographic operations in web applications.

* Generate a Key:
[source JavaScript]
----
const generateKey = async () => {
  const key = await crypto.subtle.generateKey(
    {
      name: 'AES-GCM',
      length: 256,
    },
    true,
    ['encrypt', 'decrypt']
  );
  return key;
};
----

* Encrypt Data:
[source JavaScript]
----
const encryptData = async (key, data) => {
  const encoded = new TextEncoder().encode(data);
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv: iv,
    },
    key,
    encoded
  );
  return { iv, encrypted };
};
----

==== Decrypt Data:
[source JavaScript]
----
const decryptData = async (key, iv, encrypted) => {
  const decrypted = await crypto.subtle.decrypt(
    {
      name: 'AES-GCM',
      iv: iv,
    },
    key,
    encrypted
  );
  const decoded = new TextDecoder().decode(decrypted);
  return decoded;
};
----

==== Storing Encrypted Data
Store in IndexedDB: Use IndexedDB for secure storage.
[source JavaScript]
----
const storeData = async (key, data) => {
  const { iv, encrypted } = await encryptData(key, data);
  const db = await openDB('secure-db', 1, {
    upgrade(db) {
      db.createObjectStore('store');
    },
  });
  await db.put('store', { iv, encrypted }, 'key');
};

const retrieveData = async (key) => {
  const db = await openDB('secure-db', 1);
  const data = await db.get('store', 'key');
  const decrypted = await decryptData(key, data.iv, data.encrypted);
  return decrypted;
};
----

=== 6. Regular Security Audits
* Conduct Regular Audits: Perform regular security audits and penetration testing.
* Use Tools: Utilize tools like Google Lighthouse, OWASP ZAP, and security plugins for automated security checks.
=== 7. Secure Coding Practices
* Input Validation: Validate and sanitize all user inputs.
* Output Encoding: Encode data before rendering it on the page to prevent XSS attacks.
* Limit Third-Party Scripts: Minimize and scrutinize the use of third-party scripts to avoid malicious code.